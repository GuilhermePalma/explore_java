package com.guilhermepalma;

import org.junit.Before;
import org.junit.jupiter.api.Test;

import java.time.*;
import java.time.temporal.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import static java.time.DayOfWeek.MONDAY;
import static org.junit.jupiter.api.Assertions.*;

class DateTimeExamplesTest {

    List<String> datesString = Arrays.asList("16-12-2006", "20-11-2056", "23-06-2056", "15/04/2012", "20/06/2003");
    List<LocalDate> dates = new ArrayList<>();

    @Before
    public void initialValues() {
        datesString.forEach(value -> dates.add(DateUtil.stringToAmericanDate(value)));
    }

    @Test
    void dateWithCalendar() {
        dates.forEach(value -> {
            Calendar calendarExpected = Calendar.getInstance();
            calendarExpected.set(value.getYear(), value.getMonthValue(), value.getDayOfMonth());
            assertEquals(DateTimeExamples.dateWithCalendar(calendarExpected), Date.from(value.atStartOfDay(ZoneId.systemDefault()).toInstant()));
        });
    }

    @Test
    void isFriday13() {
        List<LocalDate> isFriday = new ArrayList<>();
        List<LocalDate> notFriday = new ArrayList<>();
        for (int i = 1; i <= 12; i++) {
            LocalDate date = LocalDate.of(2020, i, 13);

            if (date.getDayOfWeek() == DayOfWeek.FRIDAY) isFriday.add(date);
            else notFriday.add(date);
        }

        isFriday.forEach(value -> assertTrue(DateTimeExamples.isFriday13(value)));
        notFriday.forEach(value -> assertFalse(DateTimeExamples.isFriday13(value)));
    }

    @Test
    void maxDateValues() {
        LocalDate maxDate = LocalDate.of(+999999999, 12, 31);
        assertEquals(maxDate, DateTimeExamples.maxDateValues());
    }

    @Test
    void minDateValues() {
        LocalDate minDate = LocalDate.of(-999999999,1,1);
        assertEquals(minDate, DateTimeExamples.minDateValues());
    }

    @Test
    void newYorkTimeZone() {
        // Value to Test
        Calendar calNewYork = Calendar.getInstance();
        calNewYork.setTimeZone(TimeZone.getTimeZone("America/New_York"));

        // Value generate for Class
        LocalDateTime localDateTime = DateTimeExamples.newYorkTimeZone();

        assertEquals(calNewYork.get(Calendar.DAY_OF_MONTH), localDateTime.getDayOfMonth());
        assertEquals((calNewYork.get(Calendar.MONTH) + 1) , localDateTime.getMonthValue());
        assertEquals(calNewYork.get(Calendar.YEAR), localDateTime.getYear());
        assertEquals(calNewYork.get(Calendar.HOUR_OF_DAY), localDateTime.getHour());
        assertEquals(calNewYork.get(Calendar.MINUTE), localDateTime.getMinute());
    }

    @Test
    void dateTimeActual() {
        // value to test
        ZonedDateTime value = ZonedDateTime.now();

        // value generated by implemented methos of class
        LocalDateTime valueToTest = DateTimeExamples.dateTimeActual();

        assertEquals(value.getHour(),valueToTest.getHour());
        assertEquals(value.getMonthValue(),valueToTest.getMonthValue());
        assertEquals(value.getDayOfMonth(),valueToTest.getDayOfMonth());
        assertEquals(value.getYear(),valueToTest.getYear());
    }

    @Test
    void dateAfterTwoYears() {
        dates.forEach(value ->{
            Calendar calendarExpected = Calendar.getInstance();
            calendarExpected.set(value.getYear(), value.getMonthValue(), value.getDayOfMonth());
            calendarExpected.set(Calendar.WEEK_OF_YEAR, -2);

            LocalDate localDateExpected = LocalDate.from(calendarExpected.toInstant());
            assertEquals(localDateExpected, DateTimeExamples.dateAfterTwoWeeks(value));
        });
    }

    @Test
    void intervalOfOneYear() {
        dates.forEach(value ->{
            // Values +1 Year
            Calendar calendarPlusOneYear = Calendar.getInstance();
            calendarPlusOneYear.set(value.getYear(), value.getMonthValue(), value.getDayOfMonth());
            calendarPlusOneYear.set(Calendar.YEAR, 1);
            LocalDate dateMoreOneYear = LocalDate.from(calendarPlusOneYear.toInstant());

            // values -1 Year
            Calendar calendarMinusOneYear = Calendar.getInstance();
            calendarMinusOneYear.set(value.getYear(), value.getMonthValue(), value.getDayOfMonth());
            calendarMinusOneYear.set(Calendar.YEAR, -1);
            LocalDate dateMinusOneYear = LocalDate.from(calendarMinusOneYear.toInstant());

            // values to tesste
            List<LocalDate> valuesToTest = DateTimeExamples.intervalOfOneYear(value);

            assertEquals(dateMoreOneYear, valuesToTest.get(0));
            assertEquals(dateMinusOneYear,  valuesToTest.get(1));
        });
    }

    @Test
    void isLeapHear() {
        for (int i = 2000; i <3000 ; i++) {

            if(i %4 ==0){
                // Check for Error Leap Hears
                if(i %100 ==0 && i %400 != 0){
                    assertFalse(DateTimeExamples.isLeapHear(Year.of(i)));
                } else{
                    assertTrue(DateTimeExamples.isLeapHear(Year.of(i)));
                }
                continue;
            }

            assertFalse(DateTimeExamples.isLeapHear(Year.of(i)));
        }
    }

    @Test
    void dateNowInDiferentsTimeZone() {
        Map<String, LocalDateTime> valuesToTest = DateTimeExamples.dateNowInDiferentsTimeZone();
        LocalDateTime dateNow = LocalDateTime.now();

        Arrays.stream(TimeZone.getAvailableIDs()).forEach(timeZoneId ->{
            LocalDateTime dateTest = dateNow.atZone(TimeZone.getTimeZone(timeZoneId).toZoneId()).toLocalDateTime();
            LocalDateTime dateToTest = valuesToTest.get(TimeZone.getTimeZone(timeZoneId).toZoneId().toString());

            // TimeZone not avalaible when usign ZoneId
            if(timeZoneId.equals("EST") || timeZoneId.equals("HST")|| timeZoneId.equals("MST")) return;

            assertEquals(dateTest.getDayOfYear(),dateToTest.getDayOfYear());
            assertEquals(dateTest.getYear(),dateToTest.getYear());
            assertEquals(dateTest.getHour(),dateToTest.getHour());
            assertEquals(dateTest.getMinute(),dateToTest.getMinute());
            assertEquals(dateTest.getSecond(),dateToTest.getSecond());
        });
    }

    @Test
    void intervalOfTenDays() {
        LocalDate c = LocalDate.now();
        List<LocalDate> datesToList = DateTimeExamples.intervalOfTenDays();
        AtomicInteger index = new AtomicInteger();

        // Check quantity expected of values
        assertEquals(21, datesToList.size());

        // Check data before Date now
        for (int i = 10; i > 0; i--) {
            assertEquals(datesToList.get(index.getAndIncrement()), c.minusDays(i));
        }

        // Check data after Date now
        for (int i = 0; i < 11; i++) {
            assertEquals(datesToList.get(index.getAndIncrement()), c.plusDays(i));
        }
    }

    @Test
    void remainingMonthsInYear() {
        int missingMonth = Month.DECEMBER.compareTo(LocalDate.now().getMonth());
        assertEquals(missingMonth, DateTimeExamples.remainingMonthsInYear().size());
    }

    @Test
    void durationPerMonth() {
        Year yearTest = Year.now();
        assertEquals(yearTest.getValue(),LocalDate.now().getYear());

        Map<String, Integer> monthDays = DateTimeExamples.durationPerMonth(yearTest);

        assertEquals(12, monthDays.size());

        for (int i = 1; i < 13; i++) {
            YearMonth monthToTest = YearMonth.of(yearTest.getValue(), i);
            String month = monthToTest.getMonth().toString();

            assertTrue(monthDays.containsKey(month));
            assertEquals(monthToTest.lengthOfMonth(), monthDays.get(month));
        }
    }

    @Test
    void listAllMondaysInMonth() {
        Set<LocalDate> dateToTest =DateTimeExamples.listAllMondaysInMonth(Calendar.AUGUST);

        LocalDate startDate = LocalDate.of(Year.now().getValue(), Month.AUGUST, 1);
        LocalDate endDate = LocalDate.of(Year.now().getValue(), Month.SEPTEMBER, 1);

        List<LocalDate> listWithDates = new ArrayList<>();
        LocalDate thisMonday = startDate.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));
        while (thisMonday.isBefore(endDate)) {
            listWithDates.add(thisMonday);
            thisMonday = thisMonday.plusWeeks(1);
        }

        assertEquals(listWithDates.size(), dateToTest.size());
        listWithDates.forEach(value -> assertTrue(dateToTest.contains(value)));
    }
}